package cashflowdb;

import java.util.List;
import cashflowdb.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table "IN_OUT_TRANSACTION".
 */
public class InOutTransaction {

    private Long id;
    private java.util.Date transactiondate;
    private String comment;
    private Double pound;
    private String howoften;
    private java.util.Date nextdate;
    private Boolean isrepetitive;
    private long categoryid;
    private long sourceid;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient InOutTransactionDao myDao;

    private Source source;
    private Long source__resolvedKey;

    private Category category;
    private Long category__resolvedKey;

    private List<RepeatTransaction> repeatTransactionList;

    public InOutTransaction() {
    }

    public InOutTransaction(Long id) {
        this.id = id;
    }

    public InOutTransaction(Long id, java.util.Date transactiondate, String comment, Double pound, String howoften, java.util.Date nextdate, Boolean isrepetitive, long categoryid, long sourceid) {
        this.id = id;
        this.transactiondate = transactiondate;
        this.comment = comment;
        this.pound = pound;
        this.howoften = howoften;
        this.nextdate = nextdate;
        this.isrepetitive = isrepetitive;
        this.categoryid = categoryid;
        this.sourceid = sourceid;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getInOutTransactionDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public java.util.Date getTransactiondate() {
        return transactiondate;
    }

    public void setTransactiondate(java.util.Date transactiondate) {
        this.transactiondate = transactiondate;
    }

    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    public Double getPound() {
        return pound;
    }

    public void setPound(Double pound) {
        this.pound = pound;
    }

    public String getHowoften() {
        return howoften;
    }

    public void setHowoften(String howoften) {
        this.howoften = howoften;
    }

    public java.util.Date getNextdate() {
        return nextdate;
    }

    public void setNextdate(java.util.Date nextdate) {
        this.nextdate = nextdate;
    }

    public Boolean getIsrepetitive() {
        return isrepetitive;
    }

    public void setIsrepetitive(Boolean isrepetitive) {
        this.isrepetitive = isrepetitive;
    }

    public long getCategoryid() {
        return categoryid;
    }

    public void setCategoryid(long categoryid) {
        this.categoryid = categoryid;
    }

    public long getSourceid() {
        return sourceid;
    }

    public void setSourceid(long sourceid) {
        this.sourceid = sourceid;
    }

    /** To-one relationship, resolved on first access. */
    public Source getSource() {
        long __key = this.sourceid;
        if (source__resolvedKey == null || !source__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            SourceDao targetDao = daoSession.getSourceDao();
            Source sourceNew = targetDao.load(__key);
            synchronized (this) {
                source = sourceNew;
            	source__resolvedKey = __key;
            }
        }
        return source;
    }

    public void setSource(Source source) {
        if (source == null) {
            throw new DaoException("To-one property 'sourceid' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.source = source;
            sourceid = source.getId();
            source__resolvedKey = sourceid;
        }
    }

    /** To-one relationship, resolved on first access. */
    public Category getCategory() {
        long __key = this.categoryid;
        if (category__resolvedKey == null || !category__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            CategoryDao targetDao = daoSession.getCategoryDao();
            Category categoryNew = targetDao.load(__key);
            synchronized (this) {
                category = categoryNew;
            	category__resolvedKey = __key;
            }
        }
        return category;
    }

    public void setCategory(Category category) {
        if (category == null) {
            throw new DaoException("To-one property 'categoryid' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.category = category;
            categoryid = category.getId();
            category__resolvedKey = categoryid;
        }
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<RepeatTransaction> getRepeatTransactionList() {
        if (repeatTransactionList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            RepeatTransactionDao targetDao = daoSession.getRepeatTransactionDao();
            List<RepeatTransaction> repeatTransactionListNew = targetDao._queryInOutTransaction_RepeatTransactionList(id);
            synchronized (this) {
                if(repeatTransactionList == null) {
                    repeatTransactionList = repeatTransactionListNew;
                }
            }
        }
        return repeatTransactionList;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetRepeatTransactionList() {
        repeatTransactionList = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}
